# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oXtwahxW4pc1uvpOipFgqFeIoSj4qNmR
"""

import numpy as np
from numpy import linalg as LA
import torch
import pygad


def solver_delta_enhanced_sparse(X,Y,F,Ms,delta):
# Y is n x f feature matrix. Nonnegative.
# F is n x k block allocation matrix. Binary.
# Ms is k x k image/mixing matrix of the raw network topology.
# beta is the ratio of KL-divergence term.
# delta is minor postive scalar to avoid trivial solution.
# MAXITER is a large integer for the maximum amount of iterations.
# step_size is the step size for gradient descent
    [n,f] = Y.shape
    k = F.shape[1]
    D = np.identity(k)
    for j in range(k):
        D[j,j] = LA.norm(F[:,j])**2

    cuda = torch.device('cuda')

    F = torch.from_numpy(F).float().to(cuda)
    Y = torch.from_numpy(Y).float().to(cuda)
    D = torch.from_numpy(D).float().to(cuda)
    X = torch.from_numpy(X).float().to(cuda)
        
    Dbar = torch.mm(D.inverse(),torch.mm(F.t(),Y))

    Ms = Ms + np.ones((k,k))*delta
    Ms = torch.from_numpy(Ms).float().to(cuda)
    
    def fitness_fun(r, solution_idx):
        r = torch.from_numpy(r).float().to(cuda)
        for l in range(f):
          r[l] = max(r[l],0)
        normr = torch.norm(r)
        r = r/normr
        R = torch.diag(r)
        M = torch.mm(torch.mm(Dbar,R),Dbar.t())
        M = M + torch.ones(k,k).to(cuda)*delta
        A = torch.mm(torch.mm(Y,R),Y.t())
        KK = torch.mm(torch.mm(F,M),F.t())        
        loss = np.linalg.norm(KK.cpu().numpy() - A.cpu().numpy(), ord = 'fro')
        fitness = 1/loss
        return fitness

    ga_instance = pygad.GA(num_generations=500,
                           num_parents_mating=10,
                           fitness_func=fitness_fun,
                           sol_per_pop=20,
                           num_genes=8189,
                           init_range_low=0.0,
                           init_range_high=1.0,
                           mutation_percent_genes=0.01,
                           mutation_type="random")
    
    ga_instance.run()
    
    return ga_instance